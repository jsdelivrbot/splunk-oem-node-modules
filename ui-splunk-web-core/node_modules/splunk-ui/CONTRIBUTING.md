Contributing
============

Dev Setup
---------
1. Clone the repo.
1. Install yarn if you haven't already: `npm install --global yarn`.
1. Install the project dependencies: `yarn`.

Building
---------
### Build the docs app
```
yarn run build:docs
```

### Build the docs app and watch for changes
```
yarn start
```
The docs app will be served at http://localhost:8080/

Testing
---------
### Run the tests
```
yarn run test
```

Scaffolding
---------

### Create a new core component
```
yarn run create:component
```

Coding Style
-----------

### Linting

Splunk UI follows the Airbnb linting rules, with the exception of using 4 spaces for indentation.
https://github.com/airbnb/javascript
```
yarn run lint
```

### Imports order

1. Module imports should follow this order:

* React
* Third-party packages
* `splunk-ui/util`
* `splunk-ui/components`
* Relative imports
* css

2. Imports in each group should be sorted by module name alphabetically

### Props Misc
* Alphabetize propTypes, defaultProps, deconstructed props and other lists of object keys.
* If the `children` prop is PropType.node, add @docs-ignore.
* Always pass `{...createTestHook(__filename)}` to the root element of a component. Function
  available by `import { createTestHook } from 'splunk-ui/util/testSupport';`
* Always pass `{...otherProps}` to the root element of a component. This is necessary for
  adding data attributes for testing or aria attributes for accessibility. It can also pass style
  without the need to defined it as a prop. This should always go last.

### Controlled Props and Uncontrolled State
* Generally, components should be controlled (managed via props) and stateless. If a component requires
  updates by the consumer after mounting, it must be stateless. That is, the consumer should have state
  and update the component props.
* Generally, state is required to manage conditions internal to the component, and therefore are not
  surfaced to consumers, such as tracking animation progress.
    * If state can have a default, the prop should be labelled as such. For instance, `defaultOpen` or
      `defaultValue`. It cannot be changed after mount.
    * If state has a callback and/or takes a default, consider if the consumer should
      be managing the state though a prop, and the state removed.
* Note, controlled/uncontrolled and state/stateless applies to specific props. A component may have
  internal state that is not surfaced, while another prop is controlled by the consumer.
* Sometimes a component may support both controlled and uncontrolled scenarios for one prop, such as
  React's native `input`. It may or may not have a `value` prop.
  In these cases, we follow the same conventions.
    * Setting a prop makes it controlled: `value="hello"`. A callback must update the prop to retain
      the chage. `value` is not set on the component's state.
    * If `value` is not set initially, the property is uncontrolled and must be stored in the
      components state. If the consumer attempts to set it later, an error must be thrown.
    * However, the `defaultValue` prop can define the initial state without the need for the
      consumer to manage state. If the consumer attempts to change it later, an error must be thrown.
    * The onChange callback functions the same in the controlled and uncontrolled scenarios.

### Methods
* Avoid public instance methods. State is always be controlled through properties.
* When public instance methods are necessary, such as for focus, they must include a description to
appear in the documentation.
* Each parameter must include a type in lowercase.
* When multiple types are supported, separate them with a | such as {number|string}.
* Each parameter must include a description in sentence case with a period.
* Optional parameters include a equal sign after the type.
* When a value is returned, a description must be included.
```
/**
* Sums a and b, and optionally c
* @param {number} a A required first value.
* @param {number} b A required second value.
* @param {number=} c An optional third value. Defaults to zero.
* @returns The sum of the numbers
*/
sum(a, b, c) {
    return a + b + (c ? c : 0);
}
```

### CSS
* If `style` prop is PropType.object, add @docs-ignore.
* Always add @docs-ignore for `className` prop. This is an internal API only.
* The `className` prop always adds a class. It does not replace the default className.
* If a contained element accepts a className, the prop should be prefixed with the element name,
such as `inputClassName`.
* Always allows users to pass a `style` prop. If a component also requires inline styles,
ensure they are merged with the style prop.
* Whenever possible, use a className rather than inline styles.
* Each element should only have one className by default. Within a CSS file, use composes to create
inheritance between classNames. If styles need to changed based on state, use data attributes.
* Never use CSS Module's `composes:` with a class in a different file. This breaks
some use cases, and is not compatible with always adding the className prop.

### Events
* Event prop callbacks are always prefixed with 'on', such as `onClick`.
* Event handles always have 'handle' as the prefix, such as `handleOnClick`.
* Event callbacks can pass two parameters, a browser `event` and a `data` object, in that order.
If there is never a browser event to pass, it's ok for a callback to only pass a data object.
* Global events, always use the `EventListener` component.
* Use the `keycode` library to identify keys by name, rather than matching integer keycodes.

### Component
* If a component only accepts specific types of children, use dot notation. For instance `Menu`
may contain `Menu.Item` and `Menu.Divider`. Such child components should be defined in a separate
file in the same directory as the parent component.

Documentation
------------
* All public components must have a documentation page.

Publishing
----------
The tools/publish.js script runs a series of pre-publish tasks and publishes the package. It should be
used for all publishing.

Prerequisite: You must have publish permissions to [Splunk's internal npm repo]
(https://repo.splunk.com/artifactory/webapp/#/artifacts/browse/tree/General/npm-solutions-local)
and set up your dev environment as directed by the "Set Me Up" section on the linked to page.

1. Create a release branch off of master with the targeted release number:
    ```
    $ git checkout master
    $ git pull
    $ git checkout -b release/v0.6.0
    ```
1. Update CHANGELOG.md.
1. Run the publish script, passing in the release type. Initially, this should be a pre-release type:
'prepatch', 'preminor', or 'premajor':
    ```
    $ node tools/run publish prepatch
    ```
1. Verify the build and continue publishing with 'prepublish' until the build is approved. Bug fixes
should be made against the release branch rather than master during this process.
    ```
    $ node tools/run publish prerelease
    ```
1. Once the prerelease package is approved and ready to go, publish the release package, passing in
the correct release type: 'patch', 'minor', or 'major':
    ```
    $ node tools/run publish patch
    ```
1. Make a pull request from the release branch back to master.
