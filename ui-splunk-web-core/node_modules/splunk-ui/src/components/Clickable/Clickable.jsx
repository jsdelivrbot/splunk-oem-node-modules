import React, { Component, PropTypes } from 'react';
import { has } from 'lodash';
import { invariant } from 'splunk-ui/util/errorHandling';
import { createTestHook } from 'splunk-ui/util/testSupport';
import toClassName from 'splunk-ui/util/toClassName';
import External from 'splunk-ui/icons/External';
import ScreenReaderContent from 'splunk-ui/components/ScreenReaderContent';
import css from './Clickable.css';


/**
* Clickable is a utility to switch between a <a> and <button> tags. If the element is disabled or
* there is no to prop, a button will be used instead. It is up to the implementer to reset styles
* for consistent appearance.
*/
class Clickable extends Component {
    static propTypes = {
        children: PropTypes.node,
        /** @docs-ignore Additional className. */
        className: PropTypes.string,
        /**
        * In some cases it may be necessary to add a class to the contents, particularly to apply.
        * flex properties that cannot be applied to buttons.
        */
        contentWrapperClassName: PropTypes.string,
        /** Add a disabled attribute and prevent clicking. */
        disabled: PropTypes.bool,
        /** A class to set on the icon wrapper.  */
        newContextIconClassName: PropTypes.string,
        /** Open  the 'to' link in a new tab. An icon will indicate as such */
        openInNewContext: PropTypes.bool,
        /** Text or elements to show to screen readers. */
        screenReaderContent: PropTypes.node,
        /**
         * A url for a link. If set and not disabled, an <a> tag will be used instead of <button>.
         */
        to: PropTypes.string,
    };

    static defaultProps = {
        disabled: false,
        newContextIconClassName: css.newContext,
    };

    constructor(props, ...rest) {
        super(props, ...rest);

        if (__DEV__ && has(props, 'href')) {
            invariant('Use Clickable\'s "to" prop instead of "href".');
        }
    }

    /**
    * Place focus on the link or button.
    */
    focus() {
        this.el.focus();
    }

    render() {
        const {
            className,
            contentWrapperClassName,
            to,
            openInNewContext,
            newContextIconClassName,
            children,
            screenReaderContent,
            ...otherProps
        } = this.props;

        const Tag = to && !otherProps.disabled ? 'a' : 'button';

        // Only set the href attribute when enabled, and therefore using an <a> tag
        if (to && !otherProps.disabled) {
            otherProps.href = to;
        }

        if (to && openInNewContext) {
            otherProps.target = '_blank';
            if (/^http/.test(to)) {
                otherProps.rel = 'noopener noreferrer';
            }
        }

        const externalIcon = openInNewContext && (
            <span className={newContextIconClassName}>
                <External size={0.8} style={{ verticalAlign: 'baseline' }} />
            </span>
        );

        return (
            <Tag
                className={toClassName(css.main, className)}
                ref={el => this.el = el}
                {...createTestHook(__filename)}
                {...otherProps}
            >
                {contentWrapperClassName && (<span className={contentWrapperClassName}>
                    {children}
                    {externalIcon}
                </span>)}
                {!contentWrapperClassName && children}
                {!contentWrapperClassName && externalIcon}

                {screenReaderContent &&
                    (<ScreenReaderContent>{screenReaderContent}</ScreenReaderContent>)}
            </Tag>
        );
    }
}

export default Clickable;
