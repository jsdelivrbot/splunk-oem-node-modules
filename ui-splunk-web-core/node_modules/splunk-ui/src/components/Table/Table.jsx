import React, { cloneElement, Children, Component, PropTypes } from 'react';
import EventListener from 'react-event-listener';
import { defer, pick, omit, throttle } from 'lodash';
import dom from 'splunk-ui/util/dom';
import { createTestHook } from 'splunk-ui/util/testSupport';
import toClassName from 'splunk-ui/util/toClassName';
import Info from 'splunk-ui/icons/Info';

// Exposed as static members of the Table class
import Body from './Body';
import Cell from './Cell';
import Footer from './Footer';
import Head from './Head';
import HeadCell from './HeadCell';
import Row from './Row';

// Internal Helper Modules
import HeadTable from './HeadTable';
import css from './Table.css';


/**
 * A styled table for disyplaying data.
 */
class Table extends Component {
    static propTypes = {
        /**
         * `children` should be `Table.Head`, `Table.Body`, or `Table.Footer`.
         */
        children: PropTypes.node,
        /** @docs-ignore. */
        className: PropTypes.string,
        /**
         * Sets the offset from the top of the window. Only applies when headType
         * is 'docked'
         */
        dockOffset: PropTypes.number,
        /**
         * Sets the table head type:
         *     * docked - The head will dock against the window
         *     * fixed - The head will be fixed in the table. The table can scroll
         *          independently from the head.
         *     * inline - The head is not fixed, but will scroll with the rest of
         *          rest of the table.
         */
        headType: PropTypes.oneOf(['docked', 'fixed', 'inline']),
        /**
         * Sets the height of the table. (Ignored if headType is 'docked')
         */
        maxHeight: PropTypes.number,
        /**
         * Adds a column to the table with an expansion button for each row that has expansion
         * content.
         */
        rowExpansion: PropTypes.oneOf(['single', 'multi', 'none']),
        /**
         * Alternate rows are given a darker background to improve readability.
         */
        stripeRows: PropTypes.bool,
        /**
         * The style attribute for the table. This is primarily useful for setting the table-layout
         * property. Note, the `style` prop is applied to the wrapper div, not the table.
         */
        tableStyle: PropTypes.object,
    };

    static defaultProps = {
        dockOffset: 0,
        headType: 'inline',
    };

    static Head = Head;
    static Body = Body;
    static Footer = Footer;
    static Row = Row;
    static Cell = Cell;
    static HeadCell = HeadCell;

    constructor(...args) {
        super(...args);
        this.handleScroll = throttle(this.updateDockedHeadState, 0);
        this.handleResize = throttle(this.updateDockedHeadState, 50);
        this.state = {};
    }

    componentDidMount() {
        defer(this.updateDockedHeadState);
    }

    componentWillReceiveProps() {
        defer(this.updateDockedHeadState);
    }

    createHead(base) {
        let headCells = base.props.children;
        if (this.props.rowExpansion === 'single' || this.props.rowExpansion === 'multi') {
            headCells = [(
                <Table.HeadCell key="more_info_head_cell">
                    <span style={{ float: 'right' }}><Info /></span>
                </Table.HeadCell>
            )].concat(Children.toArray(base.props.children));
        }
        return cloneElement(base, {
            ref: el => this.head = el,
        }, headCells);
    }

    createBody(base) {
        const bodyProps = pick(this.props, 'stripeRows', 'rowExpansion');
        return cloneElement(base, bodyProps);
    }

    isInline() {
        return this.props.headType === 'inline';
    }

    isDocked() {
        return this.props.headType === 'docked';
    }

    isFixed() {
        return this.props.headType === 'fixed';
    }

    showDocked() {
        if (!this.isDocked() || !this.table || !this.head) {
            return false;
        }
        const { dockOffset } = this.props;
        const tableTop = dom.offset(this.table).top;
        return window.pageYOffset >= tableTop - dockOffset;
    }

    showFixed() {
        return this.head && this.isFixed();
    }

    updateDockedHeadState = () => {
        if (this.isInline()) {
            return;
        }
        const { tableContainer, head, table } = this;

        const cellWidths = head.getCellWidths();
        const headHeight = head.getClientHeight();
        const tableTopWrtWindow = (dom.offset(table).top - window.pageYOffset - headHeight)
            + table.clientHeight;
        const top = (tableTopWrtWindow < 0 ? tableTopWrtWindow : 0) + this.props.dockOffset;
        this.setState({
            width: tableContainer.clientWidth,
            tableWidth: table.clientWidth,
            cellWidths,
            top,
        });
    }

    handleContainerScroll = () => {
        if (this.isInline()) {
            return;
        }
        this.setState({
            horizontalOffset: -this.tableContainer.scrollLeft,
        });
    }

    renderHeadTable(tHead) {
        if (this.showFixed() || this.showDocked()) {
            return (
                <HeadTable
                    headType={this.props.headType}
                    tHead={tHead}
                    {...this.state}
                    tableStyle={this.props.tableStyle}
                />
            );
        }
        return false;
    }

    render() {
        const {
            children,
            className,
            maxHeight,
            tableStyle,
        } = this.props;

        let tHead;
        let tBody;
        let tFooter;
        Children.forEach(children, child => {
            const { splunkUiType } = child.type;
            if (splunkUiType === 'Table.Head') {
                tHead = this.createHead(child);
            } else if (splunkUiType === 'Table.Body') {
                tBody = this.createBody(child);
            } else if (splunkUiType === 'Table.Footer') {
                tFooter = child;
            }
        });
        const tableContainerStyle = this.isDocked() ? {} : { maxHeight };
        return (
            <div
                className={toClassName(css.main, className)}
                {...createTestHook(__filename)}
                {...omit(this.props, Object.keys(Table.propTypes))}
            >
                <EventListener
                    target="window"
                    onScroll={this.handleScroll}
                    onResize={this.handleResize}
                />
                {this.renderHeadTable(tHead)}
                <div
                    onScroll={this.handleContainerScroll}
                    ref={el => this.tableContainer = el}
                    className={css.tableContainer}
                    style={tableContainerStyle}
                >
                    <table ref={el => this.table = el} className={css.table} style={tableStyle}>
                        {tHead}
                        {tFooter}
                        {tBody}
                    </table>
                </div>
            </div>
        );
    }
}

export default Table;
