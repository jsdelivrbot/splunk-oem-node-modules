import React, { Component, PropTypes } from 'react';
import { Motion, spring } from 'react-motion';
import { noop } from 'lodash';
import { createTestHook } from 'splunk-ui/util/testSupport';
import toClassName from 'splunk-ui/util/toClassName';
import css from './TransitionOpen.css';

/**
 * `TransitionOpen` is a utility component that animates the transition of its children between an
 * open and closed state.
 */
class TransitionOpen extends Component {
    static propTypes = {
        animation: PropTypes.oneOf([
            'slideFromTop',
            'slideFromRight',
            'slideFromBottom',
            'slideFromLeft',
            'expandHeight',
            'expandWidth',
        ]),
        children: PropTypes.node,
        innerClassName: PropTypes.string,
        innerStyle: PropTypes.object,
        onAnimationEnd: PropTypes.func,
        /** Whether the component is currently open or not */
        open: PropTypes.bool,
        outerClassName: PropTypes.string,
        outerStyle: PropTypes.object,
    };

    static defaultProps = {
        animation: 'expandHeight',
        innerStyle: {},
        onAnimationEnd: noop,
        open: false,
        outerStyle: {},
    };

    constructor(props, ...rest) {
        super(props, ...rest);
        this.state = {
            value: null,
            animating: false,
        };
    }

    componentWillReceiveProps(nextProps) {
        if (this.props.open !== nextProps.open) {
            this.setState({
                animating: true,
            });
        }
    }

    handleMount = (el) => {
        const { animation } = this.props;
        let value;
        if (el) {
            switch (animation) {
                case 'slideFromTop':
                case 'slideFromBottom':
                case 'expandHeight':
                    value = el.clientHeight;
                    break;
                case 'slideFromLeft':
                case 'slideFromRight':
                case 'expandWidth':
                    value = el.clientWidth;
                    break;
                default:
                    // Intentionally left empty.
            }
        }
        this.setState({ value });
    }

    handleRest = () => {
        this.setState({
            animating: false,
        });
        this.props.onAnimationEnd();
    }

    internalRender = ({ value }) => {
        const {
            children,
            animation,
            innerClassName,
            innerStyle,
            open,
            outerClassName,
            outerStyle,
            ...otherProps
        } = this.props;
        const { animating } = this.state;
        const offset = this.state.value - value;
        let transform;
        let dimension;

        if (animating) {
            switch (animation) {
                case 'slideFromTop':
                    transform = `translateY(-${offset}px)`;
                    dimension = 'height';
                    break;
                case 'slideFromBottom':
                    dimension = 'height';
                    break;
                case 'slideFromLeft':
                    transform = `translateX(${-offset}px)`;
                    dimension = 'width';
                    break;
                case 'slideFromRight':
                    dimension = 'width';
                    break;
                case 'expandHeight':
                    dimension = 'height';
                    break;
                case 'expandWidth':
                    dimension = 'width';
                    break;
                default:
                    // Intentionally left empty.
            }
        }

        return (
            <div
                className={toClassName(css.main, outerClassName)}
                {...createTestHook(__filename)}
                style={{ ...outerStyle, [dimension]: value }}
            >
                {(open || animating) && (
                    <div
                        {...otherProps}
                        ref={this.handleMount}
                        className={toClassName(css.inner, innerClassName)}
                        style={{ ...innerStyle, transform }}
                    >
                        {children}
                    </div>
                )}
            </div>
        );
    }

    render() {
        const { open } = this.props;
        const { value } = this.state;
        return (
            <Motion
                onRest={this.handleRest}
                style={{ value: spring(open ? value : 0, { precision: 1 }) }}
            >
                {this.internalRender}
            </Motion>
        );
    }
}

export default TransitionOpen;
