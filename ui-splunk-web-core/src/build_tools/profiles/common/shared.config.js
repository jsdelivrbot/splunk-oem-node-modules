var webpack = require('webpack');
var path = require('path');
var SplunkNameModuleIdsPlugin = require('../../plugins/SplunkNameModuleIdsPlugin');
var coreAliases = require('./coreAliases.config');
var mergeConfigs = require('../../util/mergeConfigs');
var resolveLoader = require('./resolve_loader.config.js');

var createBabelLoader = function (test, presets) {
    return {
        test: test,
        loader: 'babel-loader',
        exclude: /(node_modules|bower_components|contrib)/,
        query: {
            cacheDirectory: process.env.NODE_ENV === 'development',
            // for apps located outside 'web' to be able to use babel, require.resolve
            // is needed: https://github.com/babel/babel-loader/issues/166
            presets: presets.map(require.resolve),
            plugins: [
                require.resolve('babel-plugin-add-module-exports'),
                require.resolve('babel-plugin-transform-class-properties'),
                [
                    require.resolve('babel-plugin-transform-runtime'), {
                        "helpers": true, // uses babel-runtime/helpers instead of inline helpers
                        "polyfill": false,
                        "regenerator": true, // enable generator support
                    }
                ]
            ]
        }
    };
};

/**
 * Config settings that are likely to be shared by most (if not all) profiles
 * @type {Object}
 */
module.exports = mergeConfigs(coreAliases, resolveLoader, {
    plugins: [
        // Sets module ids to strings similar to what was generated by requirejs
        new SplunkNameModuleIdsPlugin({
            context: path.resolve(__dirname, '../../../js')
        }),

        // tldr: These plugins fix require path issues in moment.
        // We have moved moment.js relative to the lang directory it depends on. These plugins point
        // moment to its lang files and vice versa. This has not been an issue because we inject
        // the moment locale in i18n.py rather than using the moment api. But, webpack complains
        // that the path cannot be resolved, so we will point it to the correct path here.
        new webpack.ContextReplacementPlugin(/^\.\/locale$/, 'contrib/moment/lang'),
        new webpack.NormalModuleReplacementPlugin(/^\.\.\/moment$/, 'moment'),

        // We use a css loader (below) to build our css files. This conflicts with the inline
        // loaders we used with requirejs. This plugin strips the inline plugin.
        // TODO: If/when we fully move to webpack with no looking back to require, we should remove
        // the inline loaders and remove this plugin.
        new webpack.NormalModuleReplacementPlugin(/css\!/, function (module) {
            module.request = module.request.replace('css!', '');
            if (!/\.css$/.test(module.request)) {
                module.request += '.css';
            }
        }),

        // Squelch other webpack loaders when the requirejs contrib/text loader
        // is used. This prevents using the loader twice.
        new webpack.NormalModuleReplacementPlugin(/contrib\/text\!/, function (module) {
            module.request = '!!' + module.request;
        })
    ],
    module: {
        // Loader order matters - Webpack executes loaders right to left
        loaders: [
            {
                test: /\.css$/,
                loader: 'style-loader!css-loader'
            },
            {
                test: /\.less$/,
                loader: 'style-loader!css-loader!less-loader'
            },
            {
                test: /\.json$/,
                loader: 'json-loader'
            },
            {
                test: /\.(jpe?g|png|gif)$/i,
                loaders: [
                    'url-loader?name=../images/[name].[ext]&limit=130000'
                ]
            },
            {
                test: /\.svg$/,
                loaders: [
                    'url-loader?name=../images/[name].[ext]&limit=20000'
                ]
            },
            {
                test: /\.(woff|ttf)$/,
                loader: 'url-loader?name=../fonts/[name].[ext]&limit=20000'
            },
            // Inject an import for the ES6 global polyfills into .es/.jsx files.
            {
                test: /(\.es$|\.jsx$)/,
                loader: 'splunk-es6-polyfill'
            },
            createBabelLoader(
                /\.es$/,
                ['babel-preset-es2015']
            ),
            createBabelLoader(
                /\.jsx$/,
                ['babel-preset-es2015', 'babel-preset-react']
            ),
        ]
    },
    resolveLoader: {
        alias: {
            'contrib/text': 'raw-loader'
        }
    },
    resolve: {
        root: [
            path.resolve(__dirname, '../../../js')
        ],
        extensions: ['', '.js', '.es', '.jsx'],

        // For apps located outside 'web' to be able to resolve babel-runtime:
        //  (related? https://github.com/webpack/webpack/issues/784)
        fallback: [
            path.join(__dirname, '../../../node_modules'),
            path.join(process.env.SPLUNK_HOME || '', 'lib', 'node_modules')
        ]
    }
});
